模擬mergesort：Ex.[3,46,1,73,24,34,12,9]

              把數列拆至最小 Ex. [3,46,1,73,24,34,12,9]=>[3][46][1][73][24][34][12][9]
              兩兩比大小並排序 Ex.[3,46][1,73][24,34][9,12]
              兩組互相比大小並排序[1,3,46,73][9,12,24,34]
              最後互相比大小並排序[1,3,9,12,24,34,46,73]
              排序完成，輸出結果[1,3,9,12,24,34,46,73]

程式構想：使用遞迴的方式拆散數列，並進行搓合

1.使用分半的方式把數列拆散
    
    mid=len(list)//2  #要取整數不能用"/2" 後面讀取list的mid會出錯
    L=[:mid]  #分成左右2邊
    R=[mid:]
    
2.比較大小並搓合
  
    newlist=[]
    if L[i]>R[j]
       newlist[q]=R(j)
       j+=1
       q+=1
      
    if R[j]>L[i]
       newlist[q]=L(i)
       i+=1
       q+=1

實作：

<img src="https://github.com/tank11110/young/blob/master/%E5%9C%96%E7%89%87/1573043960901.jpg" height='400' weight='250'>
發現問題：print的結果跟預想中的不一樣，3被吃掉了且後面的數字沒有排列

模擬程式碼找出原因：

    以測資為例最後分解至[3],[1]開始merge，因[1]比[3]小所以應該要變成[1,3]
    但結果卻顯示[1,1]。接著回推程式碼，發現當R陣列跑完時L陣列還有數值，且沒有輸入剩餘的值
    解決方法：當有一陣列空了的時候，利用迴圈把另一個陣列的值依序填入
    
<img src="https://github.com/tank11110/young/blob/master/%E5%9C%96%E7%89%87/1573045037942.jpg" height='200' weight='100'>    

新增了這個程式碼後可以看見數列被正常排列了，代表完成了


*完整程式碼+詳解

<img src="https://github.com/tank11110/young/blob/master/%E5%9C%96%E7%89%87/1573045115406.jpg" height='600' weight='450'>
<img src="https://github.com/tank11110/young/blob/master/%E5%9C%96%E7%89%87/1573045067976.jpg" height='150' weight='100'>
